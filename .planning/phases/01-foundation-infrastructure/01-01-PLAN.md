---
phase: 01-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - loader.lua
  - core/services.lua
autonomous: true

must_haves:
  truths:
    - "loadstring() fetches and executes loader.lua from GitHub raw URL"
    - "loader.lua can fetch additional modules from GitHub"
    - "All Roblox services are cached before any yields"
  artifacts:
    - path: "loader.lua"
      provides: "Entry point for loadstring execution"
      min_lines: 30
    - path: "core/services.lua"
      provides: "Cached Roblox service references"
      exports: ["Services"]
  key_links:
    - from: "loader.lua"
      to: "core/services.lua"
      via: "loadModule function"
      pattern: "loadModule.*core/services"
---

<objective>
Create the project folder structure and loader entry point that enables modular script loading from GitHub.

Purpose: Establishes the foundation for all other modules - the single loadstring entry point that fetches and orchestrates module loading.

Output:
- `loader.lua` - Entry point with loadModule function and lazy loading setup
- `core/services.lua` - Cached Roblox service references
- Empty `features/` and `ui/` directories (for future phases)
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project folder structure</name>
  <files>
    - core/ (directory)
    - features/ (directory)
    - ui/ (directory)
  </files>
  <action>
Create the project folder structure as specified in RESEARCH.md:

```
sc-build-a-zoo/
├── core/           # Core modules (services, config, timing)
├── features/       # Feature modules (empty for Phase 1)
└── ui/             # UI modules (empty for Phase 1)
```

Create empty directories for `core/`, `features/`, and `ui/`. These will hold the modular script components.
  </action>
  <verify>
Directories exist:
- `ls core/` shows empty directory
- `ls features/` shows empty directory
- `ls ui/` shows empty directory
  </verify>
  <done>
All three directories (`core/`, `features/`, `ui/`) exist in project root.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create services.lua with cached Roblox services</name>
  <files>core/services.lua</files>
  <action>
Create `core/services.lua` that caches all Roblox services at script start.

**Why cache services:**
- Security: Prevents other scripts from hooking `game:GetService()` after yields
- Performance: Single lookup per service vs repeated lookups
- Must be executed BEFORE any `task.wait()` or other yields

**Services to cache (from RESEARCH.md):**
```lua
local Services = {}

-- Cache immediately on load (before any yields)
Services.Players = game:GetService("Players")
Services.ReplicatedStorage = game:GetService("ReplicatedStorage")
Services.HttpService = game:GetService("HttpService")
Services.RunService = game:GetService("RunService")
Services.TweenService = game:GetService("TweenService")
Services.UserInputService = game:GetService("UserInputService")
Services.Workspace = game:GetService("Workspace")

-- Derived references
Services.LocalPlayer = Services.Players.LocalPlayer

return Services
```

**Important:**
- Use `game:GetService()` NOT `game.ServiceName` (security)
- No yields before service caching
- Return table so other modules can import
  </action>
  <verify>
File exists at `core/services.lua` and contains:
- All 7 service references (Players, ReplicatedStorage, HttpService, RunService, TweenService, UserInputService, Workspace)
- LocalPlayer derived reference
- Returns Services table
  </verify>
  <done>
`core/services.lua` exists with all required cached services and returns the Services table.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create loader.lua entry point</name>
  <files>loader.lua</files>
  <action>
Create `loader.lua` as the single entry point for loadstring execution.

**Implementation requirements:**

1. **BASE_URL configuration:**
   - Use placeholder: `https://raw.githubusercontent.com/USER/REPO/main/`
   - Comment that user should update this to their actual repo

2. **loadModule function:**
   - Fetches module from `BASE_URL + path + ".lua"`
   - Wraps in pcall for error handling
   - Implements retry with exponential backoff (3 retries max)
   - Caches loaded modules to prevent re-fetching
   - Returns nil and warns on failure (doesn't crash script)

3. **Core module loading (upfront):**
   - Load Services first (no dependencies)
   - Comment placeholder for Config and Timing (Plan 02)

4. **Feature lazy loading (metatable):**
   - Use `setmetatable({}, { __index = ... })` pattern
   - Features load on first access, not upfront
   - Prevents executor timeout from loading too many modules

5. **UI loading placeholder:**
   - Comment placeholder for UI module (Phase 4)

6. **Return statement:**
   - Return table with all module references for external access

**Code structure from RESEARCH.md Pattern 1 (Bootstrapper Loader):**
```lua
-- Build A Zoo Script - Loader
-- Entry point for loadstring execution

local BASE_URL = "https://raw.githubusercontent.com/USER/REPO/main/"

local ModuleCache = {}

local function loadModule(path, maxRetries)
    maxRetries = maxRetries or 3
    
    -- Check cache first
    if ModuleCache[path] then
        return ModuleCache[path]
    end
    
    local retries = 0
    local lastError = nil
    
    repeat
        local fetchSuccess, source = pcall(function()
            return game:HttpGet(BASE_URL .. path .. ".lua")
        end)
        
        if fetchSuccess then
            local loadSuccess, module = pcall(function()
                return loadstring(source)()
            end)
            
            if loadSuccess then
                ModuleCache[path] = module
                return module
            else
                lastError = "Parse error: " .. tostring(module)
            end
        else
            lastError = "Fetch error: " .. tostring(source)
        end
        
        retries = retries + 1
        if retries < maxRetries then
            task.wait(2 ^ retries) -- Exponential backoff: 2s, 4s, 8s
        end
    until retries >= maxRetries
    
    warn("[Loader] Failed to load " .. path .. " after " .. maxRetries .. " attempts: " .. lastError)
    return nil
end

-- Load core modules upfront (order matters)
print("[Loader] Loading core modules...")
local Services = loadModule("core/services")

-- Lazy-load features via metatable (prevents timeout)
local Features = setmetatable({}, {
    __index = function(t, key)
        print("[Loader] Lazy loading feature: " .. key)
        local module = loadModule("features/" .. key)
        t[key] = module
        return module
    end
})

print("[Loader] Build A Zoo Script loaded successfully!")

return {
    Services = Services,
    Features = Features,
    loadModule = loadModule -- Expose for dynamic loading
}
```

**Important:**
- Use `task.wait()` not `wait()` (deprecated)
- Use `print()` for progress, `warn()` for errors
- Keep it lightweight - core modules only
  </action>
  <verify>
File exists at `loader.lua` and contains:
- BASE_URL constant with placeholder GitHub URL
- ModuleCache table for caching
- loadModule function with pcall, retry logic, exponential backoff
- Services loaded upfront via loadModule
- Features lazy-loaded via metatable
- Returns table with Services, Features, loadModule
  </verify>
  <done>
`loader.lua` exists as complete entry point that:
1. Has loadModule function with error handling and retry
2. Loads core/services upfront
3. Sets up lazy loading for features
4. Returns module references for external use
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Structure check:**
   - `ls -la` shows loader.lua in root
   - `ls -la core/` shows services.lua
   - `ls -la features/` and `ls -la ui/` show empty directories

2. **Code quality:**
   - No syntax errors in Lua files
   - All files use `game:GetService()` not `game.Service`
   - All files use `task.wait()` not `wait()`

3. **Module pattern:**
   - services.lua returns a table
   - loader.lua returns a table with Services, Features, loadModule
</verification>

<success_criteria>
- [ ] Project has `core/`, `features/`, `ui/` directories
- [ ] `loader.lua` exists with loadModule function and lazy loading
- [ ] `core/services.lua` exists with all cached Roblox services
- [ ] Both Lua files have valid syntax (no errors when parsed)
- [ ] loader.lua can be used as loadstring entry point
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md`
</output>
