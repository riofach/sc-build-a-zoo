---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - core/timing.lua
  - core/config.lua
  - core/init.lua
  - loader.lua
autonomous: true

must_haves:
  truths:
    - "Timing utility produces delays with 10-30% variance using Gaussian distribution"
    - "Config module saves and loads settings to JSON file"
    - "Config uses merge loading to preserve new defaults"
    - "Script runs without errors on Delta Executor"
  artifacts:
    - path: "core/timing.lua"
      provides: "Randomized timing utilities"
      exports: ["Timing"]
      contains: "gaussianRandom"
    - path: "core/config.lua"
      provides: "Configuration management"
      exports: ["Config"]
      contains: "JSONEncode"
    - path: "core/init.lua"
      provides: "Core module aggregator"
      exports: ["Core"]
  key_links:
    - from: "core/timing.lua"
      to: "math.random"
      via: "Box-Muller transform"
      pattern: "math\\.sqrt.*math\\.log.*math\\.cos"
    - from: "core/config.lua"
      to: "writefile/readfile"
      via: "JSON serialization"
      pattern: "writefile.*JSONEncode"
    - from: "loader.lua"
      to: "core/init"
      via: "loadModule"
      pattern: "loadModule.*core/init"
---

<objective>
Create the core utilities (timing and config) that all features depend on, plus update loader to use them.

Purpose: Provides the timing randomization for anti-detection (FARM-05) and configuration persistence for settings storage.

Output:
- `core/timing.lua` - Gaussian distribution timing utilities
- `core/config.lua` - JSON-based configuration management
- `core/init.lua` - Aggregates all core modules
- Updated `loader.lua` - Loads all core modules
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timing.lua with Gaussian distribution</name>
  <files>core/timing.lua</files>
  <action>
Create `core/timing.lua` with randomized timing utilities using Gaussian (bell-curve) distribution.

**Why Gaussian not uniform:**
- Uniform `math.random()` produces detectable patterns (perfect average over time)
- Gaussian distribution mimics human behavior (most actions near mean, some outliers)
- Requirement FARM-05: 10-30% variance for anti-detection

**Implementation from RESEARCH.md Pattern 2:**

```lua
-- core/timing.lua
-- Randomized timing utilities for anti-detection

local Timing = {}

-- Gaussian random using Box-Muller transform
-- Returns normally distributed random number with given mean and standard deviation
function Timing.gaussianRandom(mean, stdDev)
    local u1 = math.random()
    local u2 = math.random()
    -- Avoid log(0) which is undefined
    if u1 < 0.0001 then u1 = 0.0001 end
    local z0 = math.sqrt(-2.0 * math.log(u1)) * math.cos(2.0 * math.pi * u2)
    return z0 * stdDev + mean
end

-- Get delay with variance (10-30% as specified in FARM-05)
-- baseDelay: the target delay in seconds
-- variancePercent: 0.1 to 0.3 (10% to 30%), defaults to 0.2 (20%)
function Timing.getDelay(baseDelay, variancePercent)
    variancePercent = variancePercent or 0.2 -- Default 20%
    -- stdDev calculated so ~95% of values fall within variance range
    local stdDev = baseDelay * variancePercent / 2
    local delay = Timing.gaussianRandom(baseDelay, stdDev)
    -- Clamp to reasonable bounds (never negative, never too long)
    return math.max(0.1, math.min(delay, baseDelay * 2))
end

-- Convenience wrapper that waits with randomized delay
-- Usage: Timing.wait(1) -- waits ~1 second with 20% variance
function Timing.wait(baseDelay, variancePercent)
    local delay = Timing.getDelay(baseDelay, variancePercent)
    task.wait(delay)
    return delay -- Return actual delay for logging if needed
end

-- Random delay within a range (for variety in actions)
-- Usage: Timing.randomWait(0.5, 1.5) -- waits between 0.5 and 1.5 seconds
function Timing.randomWait(minDelay, maxDelay)
    local delay = minDelay + math.random() * (maxDelay - minDelay)
    task.wait(delay)
    return delay
end

return Timing
```

**Important:**
- Use `task.wait()` not deprecated `wait()`
- Clamp delays to prevent negative or extremely long waits
- Return actual delay from wait functions (useful for debugging)
- Add guard against `log(0)` which is undefined
  </action>
  <verify>
File exists at `core/timing.lua` and contains:
- `gaussianRandom` function with Box-Muller transform
- `getDelay` function with variancePercent parameter
- `wait` function using task.wait()
- `randomWait` function for range-based delays
- Returns Timing table
  </verify>
  <done>
`core/timing.lua` exists with Gaussian distribution timing that:
1. Uses Box-Muller transform for bell-curve randomness
2. Supports 10-30% variance as required by FARM-05
3. Provides both calculated delay and convenience wait functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config.lua with JSON persistence</name>
  <files>core/config.lua</files>
  <action>
Create `core/config.lua` for saving and loading user settings.

**Key requirements:**
- Store settings in executor's workspace folder (Delta Executor compatible)
- Use JSON format via HttpService:JSONEncode/JSONDecode
- Wrap ALL file operations in pcall (config corruption protection)
- Use merge loading (preserve new defaults when loading old config)

**Implementation from RESEARCH.md Pattern 4:**

```lua
-- core/config.lua
-- Configuration management with JSON persistence

local HttpService = game:GetService("HttpService")

local Config = {}

-- File paths
local FOLDER = "BuildAZoo"
local SETTINGS_FILE = FOLDER .. "/settings.json"

-- Default settings (sensible defaults - works out of box)
Config.Defaults = {
    -- Feature toggles (all off by default - user enables via UI)
    AutoCollect = false,
    AutoBuyEgg = false,
    AutoPlaceEgg = false,
    AutoHatch = false,
    
    -- Timing settings
    TimingVariance = 0.2, -- 20% variance (within 10-30% range)
    
    -- Discord webhook
    WebhookURL = "",
    WebhookEnabled = false,
    WebhookInterval = 300, -- 5 minutes
    
    -- Egg preferences (to be populated in Phase 3)
    SelectedEggType = "",
    EggPriority = {}
}

-- Current settings (initialized from defaults)
Config.Settings = {}
for key, value in pairs(Config.Defaults) do
    Config.Settings[key] = value
end

-- Ensure folder exists
local function ensureFolder()
    local success = pcall(function()
        if not isfolder(FOLDER) then
            makefolder(FOLDER)
        end
    end)
    return success
end

-- Save current settings to file
function Config:Save()
    if not ensureFolder() then
        warn("[Config] Failed to create folder")
        return false
    end
    
    local success = pcall(function()
        local encoded = HttpService:JSONEncode(self.Settings)
        writefile(SETTINGS_FILE, encoded)
    end)
    
    if success then
        print("[Config] Settings saved")
    else
        warn("[Config] Failed to save settings")
    end
    
    return success
end

-- Load settings from file (merge with defaults)
function Config:Load()
    -- Check if file exists
    local fileExists = pcall(function()
        return isfile(SETTINGS_FILE)
    end)
    
    if not fileExists or not isfile(SETTINGS_FILE) then
        print("[Config] No settings file found, using defaults")
        self:Save() -- Create default file
        return true
    end
    
    -- Read and parse file
    local readSuccess, content = pcall(readfile, SETTINGS_FILE)
    if not readSuccess then
        warn("[Config] Failed to read settings file")
        return false
    end
    
    local decodeSuccess, data = pcall(function()
        return HttpService:JSONDecode(content)
    end)
    
    if not decodeSuccess or type(data) ~= "table" then
        warn("[Config] Failed to parse settings file, using defaults")
        return false
    end
    
    -- Merge: load saved values, preserve new defaults
    -- This ensures forward compatibility when we add new settings
    for key, value in pairs(data) do
        if self.Defaults[key] ~= nil then
            -- Only load known keys (ignore obsolete settings)
            self.Settings[key] = value
        end
    end
    
    print("[Config] Settings loaded")
    return true
end

-- Get a setting value
function Config:Get(key)
    return self.Settings[key]
end

-- Set a setting value and optionally save
function Config:Set(key, value, autoSave)
    if self.Defaults[key] == nil then
        warn("[Config] Unknown setting: " .. tostring(key))
        return false
    end
    
    self.Settings[key] = value
    
    if autoSave then
        self:Save()
    end
    
    return true
end

-- Reset to defaults
function Config:Reset()
    for key, value in pairs(self.Defaults) do
        self.Settings[key] = value
    end
    self:Save()
    print("[Config] Settings reset to defaults")
end

return Config
```

**Important:**
- Use `isfolder`/`makefolder` for directory (Delta compatible)
- Use `isfile`/`readfile`/`writefile` for files (Delta compatible)
- ALL file operations wrapped in pcall
- Merge loading preserves new defaults when config file is old
- Unknown keys are ignored (forward compatibility)
  </action>
  <verify>
File exists at `core/config.lua` and contains:
- FOLDER and SETTINGS_FILE constants
- Defaults table with all default settings
- Settings table (current values)
- Save function with pcall wrapping
- Load function with merge logic
- Get/Set helper functions
- Reset function
- Returns Config table
  </verify>
  <done>
`core/config.lua` exists with JSON persistence that:
1. Saves to BuildAZoo/settings.json in executor workspace
2. Uses merge loading for forward compatibility
3. Wraps all file operations in pcall
4. Has sensible defaults that work out of box
  </done>
</task>

<task type="auto">
  <name>Task 3: Create init.lua and update loader.lua</name>
  <files>
    - core/init.lua
    - loader.lua
  </files>
  <action>
Create `core/init.lua` to aggregate all core modules, then update `loader.lua` to load it.

**Part 1: Create core/init.lua**

This module loads and returns all core modules as a single table:

```lua
-- core/init.lua
-- Core module aggregator
-- Loads all core modules and returns them as a single table

-- Note: This file is loaded via the loader's loadModule function
-- Services, Timing, and Config are loaded here to ensure correct order

return function(loadModule)
    local Core = {}
    
    print("[Core] Initializing core modules...")
    
    -- Load in dependency order
    Core.Services = loadModule("core/services")
    if not Core.Services then
        warn("[Core] Failed to load Services - critical error")
        return nil
    end
    
    Core.Timing = loadModule("core/timing")
    if not Core.Timing then
        warn("[Core] Failed to load Timing")
    end
    
    Core.Config = loadModule("core/config")
    if not Core.Config then
        warn("[Core] Failed to load Config")
    else
        -- Auto-load settings on init
        Core.Config:Load()
    end
    
    print("[Core] Core modules initialized")
    
    return Core
end
```

**Part 2: Update loader.lua**

Update the existing loader.lua to:
1. Load core/init instead of individual core modules
2. Pass loadModule to core/init
3. Keep the lazy loading for features

Updated loader.lua structure:

```lua
-- Build A Zoo Script - Loader
-- Entry point for loadstring execution

local BASE_URL = "https://raw.githubusercontent.com/USER/REPO/main/"

local ModuleCache = {}

local function loadModule(path, maxRetries)
    maxRetries = maxRetries or 3
    
    if ModuleCache[path] then
        return ModuleCache[path]
    end
    
    local retries = 0
    local lastError = nil
    
    repeat
        local fetchSuccess, source = pcall(function()
            return game:HttpGet(BASE_URL .. path .. ".lua")
        end)
        
        if fetchSuccess then
            local loadSuccess, module = pcall(function()
                return loadstring(source)()
            end)
            
            if loadSuccess then
                ModuleCache[path] = module
                return module
            else
                lastError = "Parse error: " .. tostring(module)
            end
        else
            lastError = "Fetch error: " .. tostring(source)
        end
        
        retries = retries + 1
        if retries < maxRetries then
            task.wait(2 ^ retries)
        end
    until retries >= maxRetries
    
    warn("[Loader] Failed to load " .. path .. " after " .. maxRetries .. " attempts: " .. lastError)
    return nil
end

-- Load and initialize core modules
print("[Loader] Loading Build A Zoo Script...")

local CoreInit = loadModule("core/init")
local Core = nil

if CoreInit and type(CoreInit) == "function" then
    Core = CoreInit(loadModule)
else
    warn("[Loader] Failed to load core/init")
end

-- Lazy-load features via metatable (prevents timeout)
local Features = setmetatable({}, {
    __index = function(t, key)
        print("[Loader] Lazy loading feature: " .. key)
        local module = loadModule("features/" .. key)
        t[key] = module
        return module
    end
})

-- UI placeholder (loaded in Phase 4)
local UI = nil

if Core then
    print("[Loader] Build A Zoo Script loaded successfully!")
else
    warn("[Loader] Build A Zoo Script loaded with errors - some features may not work")
end

return {
    Core = Core,
    Features = Features,
    UI = UI,
    loadModule = loadModule
}
```

**Key changes to loader.lua:**
- Loads core/init which returns a function
- Passes loadModule to core/init for module loading
- Core table now contains Services, Timing, Config
- Cleaner structure with Core namespace
  </action>
  <verify>
1. `core/init.lua` exists and:
   - Returns a function that takes loadModule
   - Loads Services, Timing, Config in order
   - Auto-loads config settings
   - Returns Core table

2. `loader.lua` updated and:
   - Loads core/init
   - Passes loadModule to CoreInit
   - Returns Core (not individual modules)
   - Keeps Features lazy loading
   - Has UI placeholder
  </verify>
  <done>
1. `core/init.lua` exists as core module aggregator
2. `loader.lua` updated to use core/init pattern
3. Full module loading chain works: loader -> core/init -> services, timing, config
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **File structure check:**
   ```
   ls core/
   # Should show: services.lua, timing.lua, config.lua, init.lua
   ```

2. **Code quality:**
   - All files use `task.wait()` not `wait()`
   - All file operations wrapped in pcall
   - No syntax errors in any Lua files

3. **Module patterns:**
   - timing.lua returns Timing table with gaussianRandom, getDelay, wait
   - config.lua returns Config table with Save, Load, Get, Set, Reset
   - init.lua returns function that returns Core table
   - loader.lua returns table with Core, Features, UI, loadModule

4. **Timing verification:**
   - getDelay function accepts baseDelay and variancePercent
   - Default variance is 0.2 (20%)
   - Uses Gaussian distribution (Box-Muller transform visible in code)

5. **Config verification:**
   - Uses BuildAZoo folder
   - Has sensible defaults
   - Merge loading preserves new defaults
</verification>

<success_criteria>
- [ ] `core/timing.lua` exists with Gaussian distribution timing
- [ ] `core/config.lua` exists with JSON persistence and merge loading
- [ ] `core/init.lua` exists as module aggregator
- [ ] `loader.lua` updated to use core/init pattern
- [ ] All Lua files have valid syntax
- [ ] Timing produces 10-30% variance (FARM-05 satisfied)
- [ ] Config saves to BuildAZoo/settings.json
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
